#!/bin/sh
set -e; set -u; set -C

# nuOS 0.0.12.99a0 - bin/nu_pkg_tree
#
# Copyright (c) 2008-2022 Chad Jacob Milios and Crop Circle Systems.
# All rights reserved.
#
# This Source Code Form is subject to the terms of the Simplified BSD License.
# If a copy of the Simplified BSD License was not distributed alongside this file, you can
# obtain one at https://www.freebsd.org/copyright/freebsd-license.html . This software
# project is not affiliated with the FreeBSD Project.
#
# Official updates and community support available at https://nuos.org .
# Professional services available at https://ccsys.com .

NUOS_VER=0.0.12.99a0

while getopts Dfi:ko:OpRSrxv OPT; do case $OPT in
	D) OPT_DEBUG=y;;
	f) OPT_FILENAME=y;;
	i) INPUT=$OPTARG;;
	k) OPT_KEEP=y;;
	o) type=$OPTARG; eval file=\"\$$OPTIND\"; case $type in
		dot|xml|txt|tbl|dir)
			setvar out_$type "$file";;
		*) exit 22; esac; shift $OPTIND;;
	O) OPT_NOOPTIONS=y;;
	p) OPT_PKGNAME=y;;
	R) OPT_NORECURSE=y;;
	S) OPT_NOSLAVE=y;;
	r) OPT_RUNONLY=y;;
	x) OPT_INDEX=y;;
	v) OPT_VERBOSE=y;;
esac; done; shift $(($OPTIND-1))

. "$(dirname "$(realpath "$0")")/../lib/nu_system.sh"
. "$(dirname "$(realpath "$0")")/../lib/nu_make.sh"
. "$(dirname "$(realpath "$0")")/../lib/nu_ports.sh"
. "$(dirname "$(realpath "$0")")/../lib/nu_collection.sh"

baseos_init -q
nuos_init -q
collection_vars_init -q

maybe_yell

if [ -n "${OPT_RUNONLY-}" ]; then
	recurse=use
else
	recurse=all
fi

walk () {
	# global work_dir dir recurse
	local node=$1 \
		dep_=
	for dep_ in `cat "$dir/$node/dependencies/collection" "$dir/$node/dependencies/$recurse" 2> /dev/null | underscore`; do
		while [ -f "$metainfo_dir/$dep_.substitute" ]; do
			dep_=`cat "$metainfo_dir/$dep_.substitute" | underscore`
		done
		[ -f "$work_dir/$dep_" ] || walk $dep_
	done
	eko $node
	touch "$work_dir/$node"
	shift
	[ $# -eq 0 ] || walk $1
}

metainfo_dir="$(dirname "$(realpath "$0")")/../pkg"
require_tmp -d work_dir

if [ -n "${INPUT-}" ]; then
	if [ -f "$INPUT/root" ]; then
		dir="$INPUT"
		if [ $# -eq 0 ]; then
			start="`cat "$INPUT/root" | underscore`"
		else
			start="`eko $@ | underscore`"
		fi
	elif [ -f "$INPUT/name" ]; then
		dir="`dirname "$INPUT"`"
		start=`basename "$INPUT"`
	else
		exit 1
	fi
	! srsly ${OPT_FILENAME-} || pkg_suffix_init
	if srsly ${OPT_INDEX-}; then
		prepare_make_conf mc retire_mc_cmd
		if srsly ${OPT_FILENAME-}; then
			tag=`cat "$dir/tag"`
		fi
		walk $start | sed -e s+_+/+ | grep / | while read -r port; do
			underscore port
			idx=`port_idx "$mc" "$dir" $port`
			if srsly ${OPT_PKGNAME-} || srsly ${OPT_FILENAME-}; then
				name=`cat "$dir/$port_/name" 2> /dev/null`
				eko $name${OPT_FILENAME:+.$tag}.$idx${OPT_FILENAME:+.$PKG_SUFFIX}
			else
				eko $idx
			fi
		done
		$retire_mc_cmd mc
	elif srsly ${OPT_PKGNAME-} || srsly ${OPT_FILENAME-}; then
		walk $start | grep _ | while read -r node; do
			eko `cat "$dir/$node/name" 2> /dev/null`${OPT_FILENAME:+.$PKG_SUFFIX}
		done
	else
		walk $start | sed -e s+_+/+
	fi
	exit
fi

require_ports_tree
prepare_make_conf make_conf retire_make_conf_cmd

for type in dot xml txt tbl; do
	if eval [ -n \"\${out_$type-}\" ]; then
		eval [ ! -e \"\$out_$type\" -o ! -s \"\$out_$type\" ]
		require_tmp tmp_$type
	fi
done

if [ -n "${out_dir-}" ]; then
	while [ "$out_dir" != "${out_dir%/}" ]; do
		out_dir=${out_dir%/}
	done
	[ ! -e "$out_dir" -o -L "$out_dir" ] || ([ -d "$out_dir" ] && [ "`ls -a "$out_dir" | xargs`" = '. ..' ])
fi
ports_tag > "$work_dir/tag"

mark_dependant () {
	# global work_dir
	local port=$1 action=$2 needs=$3 \
		needs_=
	underscore needs
	mkdir -p "$work_dir/$needs_/dependants"
	eko $port >> "$work_dir/$needs_/dependants/$action"
}

main () {
	local depth=$((${depth--1}+1)) \
		arg= arg_= \
		port= port_= port_dir= \
		collection= \
		makeargs= \
		flavor= \
		port_data= \
		action= \
		dep= dep_= \
		deps= these_deps= \
		def_opts= my_opts= \
		opts_diff= \
		lib_deps= run_deps= build_deps= \
		fetch_deps= extract_deps= patch_deps= \
		buildonly_deps= use_deps= all_deps= \
		master= master_=
	
	[ $depth -gt 0 ] || eko $@ | xargs -n1 > "$work_dir/root"
	for arg in $@; do
		underscore arg
		while [ -f "$metainfo_dir/$arg_.substitute" ]; do
			arg=`cat "$metainfo_dir/$arg_.substitute"`
			underscore arg
		done
		if [ ! -d "$work_dir/$arg_/dependencies" ]; then
			mkdir -p "$work_dir/$arg_/dependencies"
			case $arg in
				[^/]*/*)
					port=$arg
					underscore port
											
					port_dir=/usr/ports/${port%%@*}
					[ -d $port_dir ]
					
					case $port in
						*@*) flavor=${port##*@};;
						*) flavor=
					esac
					underscore port
					makeargs="$metainfo_dir/$port_.makeargs"
					
					cd "$port_dir"
					if ! canhas "${OPT_NOOPTIONS-}"; then
						require_tmp def_opts
						make __MAKE_CONF="$make_conf" PORT_DBDIR=/var/empty \
							${flavor:+FLAVOR=$flavor} \
							`cat "$makeargs" 2>/dev/null` \
							-D BATCH \
							showconfig \
								>| "$def_opts"
						require_tmp my_opts
						make "__MAKE_CONF=$make_conf" PORT_DBDIR="$PORT_DBDIR" \
							${flavor:+FLAVOR=$flavor} \
							`cat "$makeargs" 2>/dev/null` \
							-D BATCH showconfig \
								>| "$my_opts"
					fi
					
					require_tmp port_data
					
					make __MAKE_CONF="$make_conf" PORT_DBDIR="$PORT_DBDIR" \
						${flavor:+FLAVOR=$flavor} \
						`cat "$makeargs" 2>/dev/null` \
						-D BATCH \
						-v 'PKGNAME:C/^.*://:S/^/n:/' \
						-v 'LIB_DEPENDS:C/^.*://:C/^./l:&/' \
						-v 'RUN_DEPENDS:C/^.*://:C/^./r:&/' \
						-v 'BUILD_DEPENDS:C/^.*://:C/^./b:&/' \
						-v 'FETCH_DEPENDS:C/^.*://:C/^./f:&/' \
						-v 'EXTRACT_DEPENDS:C/^.*://:C/^./x:&/' \
						-v 'PATCH_DEPENDS:C/^.*://:C/^./p:&/' \
						-v '${SLAVE_PORT:N[nN][oO]:C/.+/${MASTERDIR}/:tA:C+^/usr/ports/+s:+}' \
							| xargs -n 1 >| "$port_data"
					cd "$OLDPWD"
					
					if [ -e "$work_dir/$port_/name" ]; then
						[ `cat "$work_dir/$port_/name"` = `grep ^n: "$port_data" | cut -d : -f 2` ]
					else
						grep ^n: "$port_data" | cut -d : -f 2 > "$work_dir/$port_/name"
					fi
					require_tmp lib_deps
					grep ^l: "$port_data" | cut -d : -f 2 >| "$lib_deps"
					require_tmp run_deps
					grep ^r: "$port_data" | cut -d : -f 2 >| "$run_deps"
					require_tmp build_deps
					grep ^b: "$port_data" | cut -d : -f 2 >| "$build_deps"
					require_tmp fetch_deps
					grep ^f: "$port_data" | cut -d : -f 2 >| "$fetch_deps"
					require_tmp extract_deps
					grep ^x: "$port_data" | cut -d : -f 2 >| "$extract_deps"
					require_tmp patch_deps
					grep ^p: "$port_data" | cut -d : -f 2 >| "$patch_deps"
					if ! srsly "${OPT_NOSLAVE-}"; then
						master=`grep ^s: "$port_data" | cut -d : -f 2`
						if canhas $master; then
							eko $master > "$work_dir/$port_/master"
						fi
					fi
					
					sets_union use_deps "$lib_deps" "$run_deps"
					sets_union all_deps "$use_deps" "$build_deps" "$fetch_deps" "$extract_deps" "$patch_deps"
					sets_sym_diff buildonly_deps "$all_deps" "$use_deps"

					for action in lib run build fetch extract patch all use buildonly; do
						eval these_deps=\"\$${action}_deps\"
						if [ -s "$these_deps" ]; then
							cat "$these_deps" > "$work_dir/$port_/dependencies/$action"
							local dep=
							for dep in `cat "$these_deps"`; do
								mark_dependant $port $action $dep
							done
						fi
						[ $action = $recurse ] || retire_tmp ${action}_deps
					done

					if ! canhas ${OPT_NORECURSE-}; then
						eval local recurse_deps=\"\$${recurse}_deps\"
						main `cat "$recurse_deps"`
					fi

					if canhas $master; then
						underscore master
						if [ ! -e "$work_dir/$master_/name" ]; then
							mkdir -p "$work_dir/$master_"
							makeargs="$metainfo_dir/$master_.makeargs"
							cd /usr/ports/$master
							make __MAKE_CONF="$make_conf" PORT_DBDIR="$PORT_DBDIR" \
								${flavor:+FLAVOR=$flavor} \
								`cat "$makeargs" 2>/dev/null` \
								-v PKGNAME \
									> "$work_dir/$master_/name"
							cd "$OLDPWD"
						fi
						eko $port >> "$work_dir/$master_/slaves"
					fi
					if ! srsly "${OPT_NOOPTIONS-}"; then
						if [ -s "$def_opts" ]; then
							cat "$def_opts" > "$work_dir/$port_/options"
							require_tmp opts_diff
							diff "$def_opts" "$my_opts" >| "$opts_diff" || true
							if [ -s "$opts_diff" ]; then
								sed -nEe '/^>[[:blank:]]+([^=]+=[^:]*):?.*$/{s//\1/;p;}' "$opts_diff" > "$work_dir/$port_/settings"
							fi
							retire_tmp opts_diff
						fi
						retire_tmp def_opts
						retire_tmp my_opts
					fi
					retire_tmp port_data
					
					retire_tmp ${recurse}_deps
				;;
				[^/]*)
					collection=$arg
					eval deps=\"\$COLL_$collection\"
					eko $deps | xargs -n 1 >> "$work_dir/$collection/dependencies/collection"
					for dep in $deps; do
						mark_dependant $collection collection $dep
					done
					main $deps
				;;
				*) exit 22
			esac
			eko $arg
			[ -z "${out_txt-}" ] || eko "`printf %${depth}s | tr ' ' '\t'`$arg" >> "$tmp_txt"
		fi
	done
}
main ${@:-$PKG_COLLECTION}
if [ -n "${out_dir-}" ]; then
	if [ -L "$out_dir" ]; then
		rm "$out_dir"
	fi
	mkdir -p "$out_dir"
	cp -a "$work_dir"/* "$out_dir/"
fi
retire_tmp ${OPT_KEEP:+-k} work_dir
for type in dot xml txt tbl; do
	if eval [ -n \"\${out_$type-}\" ]; then
		eval cat \"\$tmp_$type\" '>|' \"\$out_$type\"
		retire_tmp tmp_$type
	fi
done

$retire_make_conf_cmd make_conf

eko
eko "Port dependency mapping complete."
